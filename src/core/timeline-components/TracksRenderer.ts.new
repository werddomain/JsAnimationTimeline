import { StateManager } from '../stateManager';
import { EventManager } from '../eventManager';

/**
 * Interface for TracksRenderer configuration
 */
export interface TracksRendererConfig {
    container: HTMLElement;
    frameWidth: number;
    rowHeight: number;
}

/**
 * TracksRenderer Component
 * 
 * Responsible for rendering and managing timeline tracks:
 * - Rendering track rows for each layer
 * - Updating active track visual state
 * - Managing track row appearance
 */
export class TracksRenderer {
    private stateManager: StateManager;
    private eventManager: EventManager;
    private container: HTMLElement;
    private frameWidth: number;
    private rowHeight: number;
    private tracksEl: HTMLElement | null = null;
    private keyframeRenderer: (layerIdx: number, frameCount: number) => string;
    private lastUpdatedLayer: number = -1;
    private updateDebounceTimer: any = null;

    /**
     * Creates an instance of TracksRenderer
     * 
     * @param stateManager - The state manager for the timeline
     * @param eventManager - The event manager for the timeline
     * @param config - Configuration options for the renderer
     * @param keyframeRenderer - Function to render keyframes for tracks
     */
    constructor(
        stateManager: StateManager, 
        eventManager: EventManager, 
        config: TracksRendererConfig,
        keyframeRenderer: (layerIdx: number, frameCount: number) => string
    ) {
        this.stateManager = stateManager;
        this.eventManager = eventManager;
        this.container = config.container;
        this.frameWidth = config.frameWidth;
        this.rowHeight = config.rowHeight;
        this.keyframeRenderer = keyframeRenderer;
        
        // Register events
        this.registerEvents();
    }

    /**
     * Register events that this component needs to respond to
     */
    private registerEvents(): void {
        // Listen for layer selection changes
        this.eventManager.subscribe('layerSelected', (layerIdx) => {
            console.log('TracksRenderer: Received layerSelected event for layer', layerIdx);
            this.debouncedUpdateActiveTrackRow(layerIdx);
        });
        
        // Also listen to playhead move events to highlight active track row
        this.eventManager.subscribe('playheadMove', (data) => {
            if (data && typeof data.layerIdx !== 'undefined') {
                console.log('TracksRenderer: Received playheadMove event for layer', data.layerIdx);
                this.debouncedUpdateActiveTrackRow(data.layerIdx);
            }
        });
    }
    
    /**
     * Debounces multiple calls to updateActiveTrackRow within a short time frame
     */
    private debouncedUpdateActiveTrackRow(layerIdx: number): void {
        // Skip if we're already updating this layer
        if (this.lastUpdatedLayer === layerIdx) {
            console.log('TracksRenderer: Skipping duplicate update for layer', layerIdx);
            return;
        }
        
        // Remember this layer
        this.lastUpdatedLayer = layerIdx;
        
        // Clear previous timer if exists
        if (this.updateDebounceTimer) {
            clearTimeout(this.updateDebounceTimer);
        }
        
        // Set a debounce timer
        this.updateDebounceTimer = setTimeout(() => {
            this.updateActiveTrackRow(layerIdx);
            // Reset after update
            this.lastUpdatedLayer = -1;
            this.updateDebounceTimer = null;
        }, 10);
    }

    /**
     * Set the tracks element reference
     * 
     * @param tracksEl - The tracks container element
     */
    public setTracksElement(tracksEl: HTMLElement | null): void {
        this.tracksEl = tracksEl;
    }

    /**
     * Render track rows for all layers
     * 
     * @param playheadFrame - Current playhead frame
     * @param frameCount - Total number of frames
     * @returns HTML string with rendered track rows
     */
    public renderTracks(playheadFrame: number, frameCount: number): string {
        const state = this.stateManager.getState();
        
        return state.layers.map((layer, idx) => {
            const isActive = state.playhead && state.playhead.layerIdx === idx;
            return `
                <div class="timeline-grid__track-row${isActive ? ' active' : ''}" data-layer="${layer.name}" style="top:${idx*this.rowHeight}px">
                    <span class="timeline-grid__track-color-dot" style="background:${layer.color}"></span>
                    ${this.keyframeRenderer(idx, frameCount)}
                </div>
            `;
        }).join('');
    }

    /**
     * Update the active state of track rows visually without full re-render
     * 
     * @param layerIdx - Index of layer to set as active
     */
    public updateActiveTrackRow(layerIdx: number): void {
        if (!this.tracksEl) {
            console.log('TracksRenderer: tracksEl is null, cannot update active track row');
            return;
        }
        
        console.log('TracksRenderer: updating active track row for layer', layerIdx);
        
        // Update active class on track rows immediately
        const allTracks = this.tracksEl.querySelectorAll('.timeline-grid__track-row');
        
        if (!allTracks || allTracks.length === 0) {
            console.log('TracksRenderer: No track rows found in the DOM');
            return;
        }
        
        // Keep track of whether we successfully updated any track
        let trackUpdated = false;
        
        // Use forEach with an index to match against layerIdx
        allTracks.forEach((track, idx) => {
            if (idx === layerIdx) {
                track.classList.add('active');
                trackUpdated = true;
            } else {
                track.classList.remove('active');
            }
        });
        
        // If we couldn't update the track by index, try by data attribute
        if (!trackUpdated && allTracks.length > 0) {
            const state = this.stateManager.getState();
            if (state.layers[layerIdx]) {
                const layerName = state.layers[layerIdx].name;
                
                // Find the track row by layer name data attribute
                allTracks.forEach((track) => {
                    if (track.getAttribute('data-layer') === layerName) {
                        track.classList.add('active');
                        trackUpdated = true;
                    }
                });
            }
        }
    }

    /**
     * Get the row height
     * 
     * @returns The row height
     */
    public getRowHeight(): number {
        return this.rowHeight;
    }

    /**
     * Set the frame width
     * 
     * @param frameWidth - New frame width
     */
    public setFrameWidth(frameWidth: number): void {
        this.frameWidth = frameWidth;
    }

    /**
     * Get the tracks element
     * 
     * @returns The tracks element
     */
    public getTracksElement(): HTMLElement | null {
        return this.tracksEl;
    }
}
