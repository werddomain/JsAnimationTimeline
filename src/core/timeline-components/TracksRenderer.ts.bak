import { StateManager } from '../stateManager';
import { EventManager } from '../eventManager';

/**
 * Interface for TracksRenderer configuration
 */
export interface TracksRendererConfig {
    container: HTMLElement;
    frameWidth: number;
    rowHeight: number;
}

/**
 * TracksRenderer Component
 * 
 * Responsible for rendering and managing timeline tracks:
 * - Rendering track rows for each layer
 * - Updating active track visual state
 * - Managing track row appearance
 */
export class TracksRenderer {
    private stateManager: StateManager;
    private eventManager: EventManager;
    private container: HTMLElement;
    private frameWidth: number;
    private rowHeight: number;
    private tracksEl: HTMLElement | null = null;
    private keyframeRenderer: (layerIdx: number, frameCount: number) => string;

    /**
     * Creates an instance of TracksRenderer
     * 
     * @param stateManager - The state manager for the timeline
     * @param eventManager - The event manager for the timeline
     * @param config - Configuration options for the renderer
     * @param keyframeRenderer - Function to render keyframes for tracks
     */
    constructor(
        stateManager: StateManager, 
        eventManager: EventManager, 
        config: TracksRendererConfig,
        keyframeRenderer: (layerIdx: number, frameCount: number) => string
    ) {
        this.stateManager = stateManager;
        this.eventManager = eventManager;
        this.container = config.container;
        this.frameWidth = config.frameWidth;
        this.rowHeight = config.rowHeight;
        this.keyframeRenderer = keyframeRenderer;
        
        // Register events
        this.registerEvents();
    }    /**
     * Register events that this component needs to respond to
     */    private registerEvents(): void {
        // Listen for layer selection changes
        this.eventManager.subscribe('layerSelected', (layerIdx) => {
            console.log('TracksRenderer: Received layerSelected event for layer', layerIdx);
            this.updateActiveTrackRow(layerIdx);
        });
        
        // Also listen to playhead move events to highlight active track row
        this.eventManager.subscribe('playheadMove', (data) => {
            if (data && typeof data.layerIdx !== 'undefined') {
                console.log('TracksRenderer: Received playheadMove event for layer', data.layerIdx);
                setTimeout(() => {
                    this.updateActiveTrackRow(data.layerIdx);
                }, 0);
            }
        });
    }

    /**
     * Set the tracks element reference
     * 
     * @param tracksEl - The tracks container element
     */
    public setTracksElement(tracksEl: HTMLElement | null): void {
        this.tracksEl = tracksEl;
    }

    /**
     * Render track rows for all layers
     * 
     * @param playheadFrame - Current playhead frame
     * @param frameCount - Total number of frames
     * @returns HTML string with rendered track rows
     */
    public renderTracks(playheadFrame: number, frameCount: number): string {
        const state = this.stateManager.getState();
        
        return state.layers.map((layer, idx) => {
            const isActive = state.playhead && state.playhead.layerIdx === idx;
            return `
                <div class="timeline-grid__track-row${isActive ? ' active' : ''}" data-layer="${layer.name}" style="top:${idx*this.rowHeight}px">
                    <span class="timeline-grid__track-color-dot" style="background:${layer.color}"></span>
                    ${this.keyframeRenderer(idx, frameCount)}
                </div>
            `;
        }).join('');
    }    /**
     * Update the active state of track rows visually without full re-render
     * 
     * @param layerIdx - Index of layer to set as active
     */    public updateActiveTrackRow(layerIdx: number): void {
        if (!this.tracksEl) {
            console.log('TracksRenderer: tracksEl is null, cannot update active track row');
            return;
        }
        
        console.log('TracksRenderer: updating active track row for layer', layerIdx);
        
        // Force a microtask delay to ensure DOM is ready
        setTimeout(() => {
            // Update active class on track rows 
            const allTracks = this.tracksEl?.querySelectorAll('.timeline-grid__track-row');
            
            if (!allTracks || allTracks.length === 0) {
                console.log('TracksRenderer: No track rows found in the DOM');
                return;
            }
            
            console.log('TracksRenderer: found', allTracks.length, 'track rows');
            
            // Keep track of whether we successfully updated any track
            let trackUpdated = false;
            
            // Use forEach with an index to match against layerIdx
            allTracks.forEach((track, idx) => {
                if (idx === layerIdx) {
                    console.log('TracksRenderer: adding active class to track', idx);
                    track.classList.add('active');
                    trackUpdated = true;
                } else {
                    track.classList.remove('active');
                }
            });
            
            // If we couldn't update the track by index, try by data attribute
            if (!trackUpdated && allTracks.length > 0) {
                console.log('TracksRenderer: trying to update active track by state');
                const state = this.stateManager.getState();
                if (state.layers[layerIdx]) {
                    const layerName = state.layers[layerIdx].name;
                    console.log('TracksRenderer: looking for track with layer name', layerName);
                    
                    // Find the track row by layer name data attribute
                    allTracks.forEach((track) => {
                        if (track.getAttribute('data-layer') === layerName) {
                            console.log('TracksRenderer: found track by layer name', layerName);
                            track.classList.add('active');
                            trackUpdated = true;
                        }
                    });
                }
            }
            
            if (!trackUpdated) {
                console.log('TracksRenderer: Could not update any track row for layer', layerIdx);
            }
        }, 0);
    }

    /**
     * Get the row height
     * 
     * @returns The row height
     */
    public getRowHeight(): number {
        return this.rowHeight;
    }

    /**
     * Set the frame width
     * 
     * @param frameWidth - New frame width
     */
    public setFrameWidth(frameWidth: number): void {
        this.frameWidth = frameWidth;
    }

    /**
     * Get the tracks element
     * 
     * @returns The tracks element
     */
    public getTracksElement(): HTMLElement | null {
        return this.tracksEl;
    }
}
