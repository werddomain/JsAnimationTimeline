/**
 * TimelineControl class
 * Main control that coordinates plugins and manages the timeline interface
 */

import { BaseComponent } from '../components/BaseComponent';
import { SceneSelector } from '../components/SceneSelector';
import { EventEmitter } from '../core/EventEmitter';
import { DataModel, ITimelineOptions, ILayer, KeyframeType } from '../core/DataModel';
import { PluginManager } from '../core/PluginManager';
import { Events, CssClasses, PluginIds } from '../constants/Constants';
import { LayerManager } from '../plugins/LayerManager';
import { KeyboardHandler } from '../utils/KeyboardHandler';

// Timeline control options
export interface ITimelineControlOptions {
    // Container element or ID
    container: HTMLElement | string;
    // Timeline options
    timeline?: Partial<ITimelineOptions>;
    // Plugins to load
    plugins?: Record<string, any>;
}

export class TimelineControl extends BaseComponent {
    private eventEmitter: EventEmitter;
    private dataModel: DataModel;
    private pluginManager: PluginManager;
    private sceneSelector: SceneSelector | null = null;
    private keyboardHandler: KeyboardHandler | null = null;
    
    // DOM elements
    private toolbarEl: HTMLElement | null = null;
    private contentEl: HTMLElement | null = null;
    private contentContainerEl: HTMLElement | null = null;
    private layersContainerEl: HTMLElement | null = null;
    private layersHeaderEl: HTMLElement | null = null;
    private layersListEl: HTMLElement | null = null;
    private layersToolbarEl: HTMLElement | null = null;
    private keyframesAreaEl: HTMLElement | null = null;
    private timeRulerEl: HTMLElement | null = null;
    private keyframesContainerEl: HTMLElement | null = null;
    private playbackToolbarEl: HTMLElement | null = null;
    private objectToolbarEl: HTMLElement | null = null;
    
    /**
     * Constructor for TimelineControl
     * @param options - Configuration options
     */
    constructor(options: ITimelineControlOptions) {
        super(options.container, 'timeline-control');
        
        // Create event emitter
        this.eventEmitter = new EventEmitter();
        
        // Create data model with timeline options
        this.dataModel = new DataModel(options.timeline);
        
        // Create plugin manager
        this.pluginManager = new PluginManager(this.eventEmitter);
        
        // Register plugins if provided
        if (options.plugins) {
            Object.entries(options.plugins).forEach(([id, plugin]) => {
                this.pluginManager.register(id, plugin);
            });
        }
    }
    
    /**
     * Initialize the timeline control
     */
    public initialize(): void {
        console.log('Initializing TimelineControl...');
        
        try {
            // Create DOM structure if it doesn't exist
            if (!this.element) {
                console.log('Main element does not exist, mounting component...');
                // First mount the component to create the main element
                this.mount();
                console.log('Component mounted');
                
                // Then create the inner DOM structure
                this.createDomStructure();
                console.log('DOM structure created');
            }
              // Check that all required DOM elements exist
            if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
                !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl ||
                !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || 
                !this.playbackToolbarEl || !this.objectToolbarEl) {
                throw new Error('Required DOM elements not found after initialization');
            }
              // Set up scroll synchronization
            console.log('Setting up scroll synchronization...');
            this.setupScrollSynchronization();
            
            // Set up resizing capability for layers container
            console.log('Setting up layers container resize...');
            this.setupLayersResize();
            
            // Verify and adjust alignment
            console.log('Verifying layer-keyframe alignment...');
            this.verifyAlignment();              // Set up the toolbar components
            this.setupToolbar();
            
            // Verify that a default layer exists
            this.verifyDefaultLayer();
              // Set up event listeners
            this.eventEmitter.on(Events.TIMELINE_RESIZED, this.handleResize.bind(this));
            
            // Set up keyboard shortcuts
            this.setupKeyboardShortcuts();
            
            // Initialize plugins last to ensure DOM is ready
            console.log('All TimelineControl DOM elements ready, initializing plugins...');
            
            // Emit init event
            console.log('Emitting TIMELINE_INIT event');
            this.eventEmitter.emit(Events.TIMELINE_INIT, this.dataModel.getState(), this);
            
            // Set up the playhead that spans all layers
            console.log('Setting up global playhead...');
            
            // Create a playhead line that spans the entire keyframe area
            const playheadLine = document.createElement('div');
            playheadLine.className = `${CssClasses.PLAYHEAD}-line`;
            playheadLine.style.position = 'absolute';
            playheadLine.style.top = '0';
            playheadLine.style.height = '100%';
            playheadLine.style.width = '2px';
            playheadLine.style.backgroundColor = 'var(--timeline-selection-color, #f44336)';
            playheadLine.style.zIndex = '5';
            playheadLine.style.pointerEvents = 'none';
            
            this.keyframesContainerEl.appendChild(playheadLine);
            
            // Listen for playhead movement and update the vertical line
            this.eventEmitter.on(Events.PLAYHEAD_MOVED, (event: any) => {
                const position = event.data.position;
                const scrollLeft = this.keyframesContainerEl?.scrollLeft || 0;
                
                // Position playhead line relative to container scroll
                playheadLine.style.left = `${position - scrollLeft}px`;
            });
            
            // Listen for horizontal scroll and update playhead position
            this.eventEmitter.on(Events.SCROLL_HORIZONTAL, () => {
                const currentTime = this.dataModel.getCurrentTime();
                const position = currentTime * this.dataModel.getTimeScale();
                const scrollLeft = this.keyframesContainerEl?.scrollLeft || 0;
                
                // Update playhead line position
                playheadLine.style.left = `${position - scrollLeft}px`;
            });
            
            console.log('Global playhead set up successfully');
            console.log('TimelineControl initialized successfully');
        } catch (error) {
            console.error('Error initializing TimelineControl:', error);
            throw error; // Rethrow to notify callers
        }
    }
      /**
     * Render the timeline control
     * @returns HTML string representation
     */
    public render(): string {
        return `
            <div class="${CssClasses.TIMELINE_CONTROL}" id="${this.id}">
                <div class="${CssClasses.TIMELINE_TOOLBAR}"></div>
                <div class="${CssClasses.TIMELINE_CONTENT}">
                    <div class="${CssClasses.TIMELINE_CONTENT_CONTAINER}">                        <div class="${CssClasses.TIMELINE_LAYERS_CONTAINER}">
                            <div class="${CssClasses.TIMELINE_LAYERS_HEADER}"></div>
                            <div class="${CssClasses.LAYER_LIST}"></div>
                            <div class="${CssClasses.TIMELINE_LAYERS_TOOLBAR}"></div>
                        </div>
                        <div class="${CssClasses.TIMELINE_KEYFRAMES_AREA}">
                            <div class="${CssClasses.TIMELINE_RULER}"></div>
                            <div class="${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}"></div>
                            <div class="${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}"></div>
                        </div>
                    </div>
                </div>
                <div class="${CssClasses.TIMELINE_OBJECT_TOOLBAR}"></div>
            </div>
        `;
    }
      /**
     * Update the timeline control
     * @param data - New data for the timeline
     */
    public update(data?: any): void {
        if (data) {
            this.dataModel.setState(data);
        }
        
        // Verify default layer to ensure we always have at least one layer
        this.verifyDefaultLayer();
    }
    
    /**
     * Destroy the timeline control and clean up resources
     */
    public destroy(): void {
        // Destroy all plugins
        this.pluginManager.destroyAll();
        
        // Remove event listeners
        this.eventEmitter.clear();
        
        // Emit destroyed event
        this.eventEmitter.emit(Events.TIMELINE_DESTROYED, {}, this);
    }
    
    /**
     * Create the DOM structure for the timeline control
     */    private createDomStructure(): void {
        // Check if element already exists
        if (!this.element) {
            // Render without initializing to avoid recursion
            const html = this.render();
            this.container.innerHTML = html;
            this.element = this.container.firstElementChild as HTMLElement;
        }
        
        // Get the DOM elements
        if (!this.element) {
            throw new Error('Failed to create timeline control element');
        }
        
        this.toolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_TOOLBAR}`);
        this.contentEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT}`);
        this.contentContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT_CONTAINER}`);        this.layersContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_CONTAINER}`);
        this.layersHeaderEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_HEADER}`);
        this.layersListEl = this.element.querySelector(`.${CssClasses.LAYER_LIST}`);
        this.layersToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_TOOLBAR}`);
        this.keyframesAreaEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_AREA}`);
        this.timeRulerEl = this.element.querySelector(`.${CssClasses.TIMELINE_RULER}`);
        this.keyframesContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}`);
        this.playbackToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}`);
        this.objectToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_OBJECT_TOOLBAR}`);
        
        // Initialize the layers header with column titles
        if (this.layersHeaderEl) {
            this.layersHeaderEl.innerHTML = `
                <div class="layers-header-title">Layers</div>
                <div class="layers-header-actions">
                    <span class="header-icon" title="Toggle visibility of all layers">👁️</span>
                    <span class="header-icon" title="Toggle lock of all layers">🔓</span>
                </div>
            `;
        }
          
        if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
            !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || !this.objectToolbarEl ||
            !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl || !this.playbackToolbarEl) {
            throw new Error('Failed to get all timeline control elements');
        }
    }    /**
     * Set up scroll synchronization between layers and keyframes
     */
    private setupScrollSynchronization(): void {
        if (!this.layersContainerEl || !this.layersListEl || !this.keyframesContainerEl || !this.timeRulerEl) {
            throw new Error('Cannot set up scroll synchronization - required elements not found');
        }
        
        console.log('Setting up scroll synchronization...');
        
        // Sync vertical scrolling with debouncing to prevent loops
        let isScrollingKeyframes = false;
        let isScrollingLayers = false;
        
        // Keyframes to Layers sync
        this.keyframesContainerEl.addEventListener('scroll', () => {
            if (!isScrollingLayers && this.layersListEl) {
                isScrollingKeyframes = true;
                this.layersListEl.scrollTop = this.keyframesContainerEl!.scrollTop;
                setTimeout(() => { isScrollingKeyframes = false; }, 10);
            }
        });
        
        // Layers to Keyframes sync
        this.layersListEl.addEventListener('scroll', () => {
            if (!isScrollingKeyframes && this.keyframesContainerEl) {
                isScrollingLayers = true;
                this.keyframesContainerEl.scrollTop = this.layersListEl!.scrollTop;
                setTimeout(() => { isScrollingLayers = false; }, 10);
            }
        });
        
        // Sync horizontal scrolling between ruler and keyframes
        this.keyframesContainerEl.addEventListener('scroll', () => {
            const rulerContent = this.timeRulerEl!.querySelector('.timeline-ruler-content');
            if (rulerContent) {
                (rulerContent as HTMLElement).style.transform = 
                    `translateX(-${this.keyframesContainerEl!.scrollLeft}px)`;
            } else {
                console.error('Ruler content element not found');
            }
            
            // Emit scroll event
            this.eventEmitter.emit(Events.SCROLL_HORIZONTAL, {
                position: this.keyframesContainerEl!.scrollLeft
            }, this);
        });
        
        console.log('Scroll synchronization set up successfully');
    }    /**
     * Handle resize event
     */
    private handleResize(): void {
        // Update the timeline display and verify alignment
        this.verifyAlignment();
        
        // Emit resize event
        this.eventEmitter.emit(Events.TIMELINE_RESIZED, {
            width: this.element?.clientWidth,
            height: this.element?.clientHeight
        }, this);
    }
    
    /**
     * Set up the toolbar components
     */
    private setupToolbar(): void {
        if (!this.toolbarEl) {
            throw new Error('Toolbar element not found');
        }
        
        console.log('Setting up toolbar components...');
        
        // Create scene selector
        this.sceneSelector = new SceneSelector({
            container: this.toolbarEl,
            dataModel: this.dataModel,
            eventEmitter: this.eventEmitter
        });
        
        this.sceneSelector.mount();
        this.sceneSelector.initialize();
        
        // Add keyframe button
        const addKeyframeBtn = document.createElement('button');
        addKeyframeBtn.className = CssClasses.ADD_KEYFRAME_BUTTON;
        addKeyframeBtn.textContent = 'Add Keyframe';
        addKeyframeBtn.title = 'Add a keyframe at the current time';
        addKeyframeBtn.addEventListener('click', this.handleAddKeyframeClick.bind(this));
        
        this.toolbarEl.appendChild(addKeyframeBtn);
        
        // Set up the layers container resize functionality
        this.setupLayersResize();
        
        // Set up keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    
    /**
     * Set up keyboard shortcuts for common timeline operations
     */
    private setupKeyboardShortcuts(): void {
        // Initialize the KeyboardHandler
        if (!this.keyboardHandler) {
            this.keyboardHandler = new KeyboardHandler({
                eventEmitter: this.eventEmitter,
                dataModel: this.dataModel,
                timelineElement: this.element as HTMLElement
            });
        }
    }
    
    /**
     * Handle adding a keyframe at the current playhead position
     */
    private handleAddKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.SOLID
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Handle adding a hollow keyframe at the current playhead position
     */
    private handleAddHollowKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a hollow keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.HOLLOW
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Create a tween between selected keyframes
     * @param type - Type of tween to create
     */
    private handleCreateTweenClick(type: 'motion' | 'shape'): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        
        if (selectedLayerIds.length !== 1) {
            console.warn('Please select exactly one layer for tween creation');
            return;
        }
        
        const layerId = selectedLayerIds[0];
        const selectedKeyframeIds = this.dataModel.getSelectedKeyframeIds(layerId);
        
        if (selectedKeyframeIds.length !== 2) {
            console.warn('Please select exactly two keyframes for tween creation');
            return;
        }
        
        // Get the keyframes and sort them by time
        const keyframe1 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[0]);
        const keyframe2 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[1]);
        
        if (!keyframe1 || !keyframe2) {
            console.error('Failed to get selected keyframes');
            return;
        }
        
        // Sort keyframes by time
        const [startKeyframe, endKeyframe] = keyframe1.time < keyframe2.time ? 
            [keyframe1, keyframe2] : [keyframe2, keyframe1];
        
        // Create the tween
        import('../core/DataModel').then(({ TweenType }) => {
            const tweenType = type === 'motion' ? TweenType.MOTION : TweenType.SHAPE;
            
            // Create tween object
            const tweenId = `tween-${Date.now()}`;
            const tween = {
                id: tweenId,
                startKeyframeId: startKeyframe.id,
                endKeyframeId: endKeyframe.id,
                type: tweenType,
                properties: [] // Empty array for properties being tweened
            };
            
            // Update the start keyframe with the tween
            this.dataModel.updateKeyframe(layerId, startKeyframe.id, {
                ...startKeyframe,
                nextTween: tween
            });
        });
    }
    
    /**
     * Toggle playback state (play/pause)
     */
    private togglePlayback(): void {
        // This is a placeholder for playback functionality
        // In a real implementation, this would start/stop animation
        console.log('Toggle playback');
        this.eventEmitter.emit(Events.TOGGLE_PLAYBACK, {}, this);
    }
    
    /**
     * Step backward one frame
     */
    private stepBackward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.max(0, currentTime - frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
    
    /**
     * Step forward one frame
     */
    private stepForward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const duration = this.dataModel.getDuration();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.min(duration, currentTime + frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
      /**
     * Render the timeline control
     * @returns HTML string representation
     */
    public render(): string {
        return `
            <div class="${CssClasses.TIMELINE_CONTROL}" id="${this.id}">
                <div class="${CssClasses.TIMELINE_TOOLBAR}"></div>
                <div class="${CssClasses.TIMELINE_CONTENT}">
                    <div class="${CssClasses.TIMELINE_CONTENT_CONTAINER}">                        <div class="${CssClasses.TIMELINE_LAYERS_CONTAINER}">
                            <div class="${CssClasses.TIMELINE_LAYERS_HEADER}"></div>
                            <div class="${CssClasses.LAYER_LIST}"></div>
                            <div class="${CssClasses.TIMELINE_LAYERS_TOOLBAR}"></div>
                        </div>
                        <div class="${CssClasses.TIMELINE_KEYFRAMES_AREA}">
                            <div class="${CssClasses.TIMELINE_RULER}"></div>
                            <div class="${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}"></div>
                            <div class="${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}"></div>
                        </div>
                    </div>
                </div>
                <div class="${CssClasses.TIMELINE_OBJECT_TOOLBAR}"></div>
            </div>
        `;
    }
      /**
     * Update the timeline control
     * @param data - New data for the timeline
     */
    public update(data?: any): void {
        if (data) {
            this.dataModel.setState(data);
        }
        
        // Verify default layer to ensure we always have at least one layer
        this.verifyDefaultLayer();
    }
    
    /**
     * Destroy the timeline control and clean up resources
     */
    public destroy(): void {
        // Destroy all plugins
        this.pluginManager.destroyAll();
        
        // Remove event listeners
        this.eventEmitter.clear();
        
        // Emit destroyed event
        this.eventEmitter.emit(Events.TIMELINE_DESTROYED, {}, this);
    }
    
    /**
     * Create the DOM structure for the timeline control
     */    private createDomStructure(): void {
        // Check if element already exists
        if (!this.element) {
            // Render without initializing to avoid recursion
            const html = this.render();
            this.container.innerHTML = html;
            this.element = this.container.firstElementChild as HTMLElement;
        }
        
        // Get the DOM elements
        if (!this.element) {
            throw new Error('Failed to create timeline control element');
        }
        
        this.toolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_TOOLBAR}`);
        this.contentEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT}`);
        this.contentContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT_CONTAINER}`);        this.layersContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_CONTAINER}`);
        this.layersHeaderEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_HEADER}`);
        this.layersListEl = this.element.querySelector(`.${CssClasses.LAYER_LIST}`);
        this.layersToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_TOOLBAR}`);
        this.keyframesAreaEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_AREA}`);
        this.timeRulerEl = this.element.querySelector(`.${CssClasses.TIMELINE_RULER}`);
        this.keyframesContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}`);
        this.playbackToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}`);
        this.objectToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_OBJECT_TOOLBAR}`);
        
        // Initialize the layers header with column titles
        if (this.layersHeaderEl) {
            this.layersHeaderEl.innerHTML = `
                <div class="layers-header-title">Layers</div>
                <div class="layers-header-actions">
                    <span class="header-icon" title="Toggle visibility of all layers">👁️</span>
                    <span class="header-icon" title="Toggle lock of all layers">🔓</span>
                </div>
            `;
        }
          
        if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
            !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || !this.objectToolbarEl ||
            !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl || !this.playbackToolbarEl) {
            throw new Error('Failed to get all timeline control elements');
        }
    }    /**
     * Set up scroll synchronization between layers and keyframes
     */
    private setupScrollSynchronization(): void {
        if (!this.layersContainerEl || !this.layersListEl || !this.keyframesContainerEl || !this.timeRulerEl) {
            throw new Error('Cannot set up scroll synchronization - required elements not found');
        }
        
        console.log('Setting up scroll synchronization...');
        
        // Sync vertical scrolling with debouncing to prevent loops
        let isScrollingKeyframes = false;
        let isScrollingLayers = false;
        
        // Keyframes to Layers sync
        this.keyframesContainerEl.addEventListener('scroll', () => {
            if (!isScrollingLayers && this.layersListEl) {
                isScrollingKeyframes = true;
                this.layersListEl.scrollTop = this.keyframesContainerEl!.scrollTop;
                setTimeout(() => { isScrollingKeyframes = false; }, 10);
            }
        });
        
        // Layers to Keyframes sync
        this.layersListEl.addEventListener('scroll', () => {
            if (!isScrollingKeyframes && this.keyframesContainerEl) {
                isScrollingLayers = true;
                this.keyframesContainerEl.scrollTop = this.layersListEl!.scrollTop;
                setTimeout(() => { isScrollingLayers = false; }, 10);
            }
        });
        
        // Sync horizontal scrolling between ruler and keyframes
        this.keyframesContainerEl.addEventListener('scroll', () => {
            const rulerContent = this.timeRulerEl!.querySelector('.timeline-ruler-content');
            if (rulerContent) {
                (rulerContent as HTMLElement).style.transform = 
                    `translateX(-${this.keyframesContainerEl!.scrollLeft}px)`;
            } else {
                console.error('Ruler content element not found');
            }
            
            // Emit scroll event
            this.eventEmitter.emit(Events.SCROLL_HORIZONTAL, {
                position: this.keyframesContainerEl!.scrollLeft
            }, this);
        });
        
        console.log('Scroll synchronization set up successfully');
    }    /**
     * Handle resize event
     */
    private handleResize(): void {
        // Update the timeline display and verify alignment
        this.verifyAlignment();
        
        // Emit resize event
        this.eventEmitter.emit(Events.TIMELINE_RESIZED, {
            width: this.element?.clientWidth,
            height: this.element?.clientHeight
        }, this);
    }
    
    /**
     * Set up the toolbar components
     */
    private setupToolbar(): void {
        if (!this.toolbarEl) {
            throw new Error('Toolbar element not found');
        }
        
        console.log('Setting up toolbar components...');
        
        // Create scene selector
        this.sceneSelector = new SceneSelector({
            container: this.toolbarEl,
            dataModel: this.dataModel,
            eventEmitter: this.eventEmitter
        });
        
        this.sceneSelector.mount();
        this.sceneSelector.initialize();
        
        // Add keyframe button
        const addKeyframeBtn = document.createElement('button');
        addKeyframeBtn.className = CssClasses.ADD_KEYFRAME_BUTTON;
        addKeyframeBtn.textContent = 'Add Keyframe';
        addKeyframeBtn.title = 'Add a keyframe at the current time';
        addKeyframeBtn.addEventListener('click', this.handleAddKeyframeClick.bind(this));
        
        this.toolbarEl.appendChild(addKeyframeBtn);
        
        // Set up the layers container resize functionality
        this.setupLayersResize();
        
        // Set up keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    
    /**
     * Set up keyboard shortcuts for common timeline operations
     */
    private setupKeyboardShortcuts(): void {
        // Initialize the KeyboardHandler
        if (!this.keyboardHandler) {
            this.keyboardHandler = new KeyboardHandler({
                eventEmitter: this.eventEmitter,
                dataModel: this.dataModel,
                timelineElement: this.element as HTMLElement
            });
        }
    }
    
    /**
     * Handle adding a keyframe at the current playhead position
     */
    private handleAddKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.SOLID
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Handle adding a hollow keyframe at the current playhead position
     */
    private handleAddHollowKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a hollow keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.HOLLOW
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Create a tween between selected keyframes
     * @param type - Type of tween to create
     */
    private handleCreateTweenClick(type: 'motion' | 'shape'): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        
        if (selectedLayerIds.length !== 1) {
            console.warn('Please select exactly one layer for tween creation');
            return;
        }
        
        const layerId = selectedLayerIds[0];
        const selectedKeyframeIds = this.dataModel.getSelectedKeyframeIds(layerId);
        
        if (selectedKeyframeIds.length !== 2) {
            console.warn('Please select exactly two keyframes for tween creation');
            return;
        }
        
        // Get the keyframes and sort them by time
        const keyframe1 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[0]);
        const keyframe2 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[1]);
        
        if (!keyframe1 || !keyframe2) {
            console.error('Failed to get selected keyframes');
            return;
        }
        
        // Sort keyframes by time
        const [startKeyframe, endKeyframe] = keyframe1.time < keyframe2.time ? 
            [keyframe1, keyframe2] : [keyframe2, keyframe1];
        
        // Create the tween
        import('../core/DataModel').then(({ TweenType }) => {
            const tweenType = type === 'motion' ? TweenType.MOTION : TweenType.SHAPE;
            
            // Create tween object
            const tweenId = `tween-${Date.now()}`;
            const tween = {
                id: tweenId,
                startKeyframeId: startKeyframe.id,
                endKeyframeId: endKeyframe.id,
                type: tweenType,
                properties: [] // Empty array for properties being tweened
            };
            
            // Update the start keyframe with the tween
            this.dataModel.updateKeyframe(layerId, startKeyframe.id, {
                ...startKeyframe,
                nextTween: tween
            });
        });
    }
    
    /**
     * Toggle playback state (play/pause)
     */
    private togglePlayback(): void {
        // This is a placeholder for playback functionality
        // In a real implementation, this would start/stop animation
        console.log('Toggle playback');
        this.eventEmitter.emit(Events.TOGGLE_PLAYBACK, {}, this);
    }
    
    /**
     * Step backward one frame
     */
    private stepBackward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.max(0, currentTime - frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
    
    /**
     * Step forward one frame
     */
    private stepForward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const duration = this.dataModel.getDuration();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.min(duration, currentTime + frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
      /**
     * Render the timeline control
     * @returns HTML string representation
     */
    public render(): string {
        return `
            <div class="${CssClasses.TIMELINE_CONTROL}" id="${this.id}">
                <div class="${CssClasses.TIMELINE_TOOLBAR}"></div>
                <div class="${CssClasses.TIMELINE_CONTENT}">
                    <div class="${CssClasses.TIMELINE_CONTENT_CONTAINER}">                        <div class="${CssClasses.TIMELINE_LAYERS_CONTAINER}">
                            <div class="${CssClasses.TIMELINE_LAYERS_HEADER}"></div>
                            <div class="${CssClasses.LAYER_LIST}"></div>
                            <div class="${CssClasses.TIMELINE_LAYERS_TOOLBAR}"></div>
                        </div>
                        <div class="${CssClasses.TIMELINE_KEYFRAMES_AREA}">
                            <div class="${CssClasses.TIMELINE_RULER}"></div>
                            <div class="${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}"></div>
                            <div class="${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}"></div>
                        </div>
                    </div>
                </div>
                <div class="${CssClasses.TIMELINE_OBJECT_TOOLBAR}"></div>
            </div>
        `;
    }
      /**
     * Update the timeline control
     * @param data - New data for the timeline
     */
    public update(data?: any): void {
        if (data) {
            this.dataModel.setState(data);
        }
        
        // Verify default layer to ensure we always have at least one layer
        this.verifyDefaultLayer();
    }
    
    /**
     * Destroy the timeline control and clean up resources
     */
    public destroy(): void {
        // Destroy all plugins
        this.pluginManager.destroyAll();
        
        // Remove event listeners
        this.eventEmitter.clear();
        
        // Emit destroyed event
        this.eventEmitter.emit(Events.TIMELINE_DESTROYED, {}, this);
    }
    
    /**
     * Create the DOM structure for the timeline control
     */    private createDomStructure(): void {
        // Check if element already exists
        if (!this.element) {
            // Render without initializing to avoid recursion
            const html = this.render();
            this.container.innerHTML = html;
            this.element = this.container.firstElementChild as HTMLElement;
        }
        
        // Get the DOM elements
        if (!this.element) {
            throw new Error('Failed to create timeline control element');
        }
        
        this.toolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_TOOLBAR}`);
        this.contentEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT}`);
        this.contentContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT_CONTAINER}`);        this.layersContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_CONTAINER}`);
        this.layersHeaderEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_HEADER}`);
        this.layersListEl = this.element.querySelector(`.${CssClasses.LAYER_LIST}`);
        this.layersToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_TOOLBAR}`);
        this.keyframesAreaEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_AREA}`);
        this.timeRulerEl = this.element.querySelector(`.${CssClasses.TIMELINE_RULER}`);
        this.keyframesContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}`);
        this.playbackToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}`);
        this.objectToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_OBJECT_TOOLBAR}`);
        
        // Initialize the layers header with column titles
        if (this.layersHeaderEl) {
            this.layersHeaderEl.innerHTML = `
                <div class="layers-header-title">Layers</div>
                <div class="layers-header-actions">
                    <span class="header-icon" title="Toggle visibility of all layers">👁️</span>
                    <span class="header-icon" title="Toggle lock of all layers">🔓</span>
                </div>
            `;
        }
          
        if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
            !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || !this.objectToolbarEl ||
            !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl || !this.playbackToolbarEl) {
            throw new Error('Failed to get all timeline control elements');
        }
    }    /**
     * Set up scroll synchronization between layers and keyframes
     */
    private setupScrollSynchronization(): void {
        if (!this.layersContainerEl || !this.layersListEl || !this.keyframesContainerEl || !this.timeRulerEl) {
            throw new Error('Cannot set up scroll synchronization - required elements not found');
        }
        
        console.log('Setting up scroll synchronization...');
        
        // Sync vertical scrolling with debouncing to prevent loops
        let isScrollingKeyframes = false;
        let isScrollingLayers = false;
        
        // Keyframes to Layers sync
        this.keyframesContainerEl.addEventListener('scroll', () => {
            if (!isScrollingLayers && this.layersListEl) {
                isScrollingKeyframes = true;
                this.layersListEl.scrollTop = this.keyframesContainerEl!.scrollTop;
                setTimeout(() => { isScrollingKeyframes = false; }, 10);
            }
        });
        
        // Layers to Keyframes sync
        this.layersListEl.addEventListener('scroll', () => {
            if (!isScrollingKeyframes && this.keyframesContainerEl) {
                isScrollingLayers = true;
                this.keyframesContainerEl.scrollTop = this.layersListEl!.scrollTop;
                setTimeout(() => { isScrollingLayers = false; }, 10);
            }
        });
        
        // Sync horizontal scrolling between ruler and keyframes
        this.keyframesContainerEl.addEventListener('scroll', () => {
            const rulerContent = this.timeRulerEl!.querySelector('.timeline-ruler-content');
            if (rulerContent) {
                (rulerContent as HTMLElement).style.transform = 
                    `translateX(-${this.keyframesContainerEl!.scrollLeft}px)`;
            } else {
                console.error('Ruler content element not found');
            }
            
            // Emit scroll event
            this.eventEmitter.emit(Events.SCROLL_HORIZONTAL, {
                position: this.keyframesContainerEl!.scrollLeft
            }, this);
        });
        
        console.log('Scroll synchronization set up successfully');
    }    /**
     * Handle resize event
     */
    private handleResize(): void {
        // Update the timeline display and verify alignment
        this.verifyAlignment();
        
        // Emit resize event
        this.eventEmitter.emit(Events.TIMELINE_RESIZED, {
            width: this.element?.clientWidth,
            height: this.element?.clientHeight
        }, this);
    }
    
    /**
     * Set up the toolbar components
     */
    private setupToolbar(): void {
        if (!this.toolbarEl) {
            throw new Error('Toolbar element not found');
        }
        
        console.log('Setting up toolbar components...');
        
        // Create scene selector
        this.sceneSelector = new SceneSelector({
            container: this.toolbarEl,
            dataModel: this.dataModel,
            eventEmitter: this.eventEmitter
        });
        
        this.sceneSelector.mount();
        this.sceneSelector.initialize();
        
        // Add keyframe button
        const addKeyframeBtn = document.createElement('button');
        addKeyframeBtn.className = CssClasses.ADD_KEYFRAME_BUTTON;
        addKeyframeBtn.textContent = 'Add Keyframe';
        addKeyframeBtn.title = 'Add a keyframe at the current time';
        addKeyframeBtn.addEventListener('click', this.handleAddKeyframeClick.bind(this));
        
        this.toolbarEl.appendChild(addKeyframeBtn);
        
        // Set up the layers container resize functionality
        this.setupLayersResize();
        
        // Set up keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    
    /**
     * Set up keyboard shortcuts for common timeline operations
     */
    private setupKeyboardShortcuts(): void {
        // Initialize the KeyboardHandler
        if (!this.keyboardHandler) {
            this.keyboardHandler = new KeyboardHandler({
                eventEmitter: this.eventEmitter,
                dataModel: this.dataModel,
                timelineElement: this.element as HTMLElement
            });
        }
    }
    
    /**
     * Handle adding a keyframe at the current playhead position
     */
    private handleAddKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.SOLID
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Handle adding a hollow keyframe at the current playhead position
     */
    private handleAddHollowKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a hollow keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.HOLLOW
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Create a tween between selected keyframes
     * @param type - Type of tween to create
     */
    private handleCreateTweenClick(type: 'motion' | 'shape'): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        
        if (selectedLayerIds.length !== 1) {
            console.warn('Please select exactly one layer for tween creation');
            return;
        }
        
        const layerId = selectedLayerIds[0];
        const selectedKeyframeIds = this.dataModel.getSelectedKeyframeIds(layerId);
        
        if (selectedKeyframeIds.length !== 2) {
            console.warn('Please select exactly two keyframes for tween creation');
            return;
        }
        
        // Get the keyframes and sort them by time
        const keyframe1 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[0]);
        const keyframe2 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[1]);
        
        if (!keyframe1 || !keyframe2) {
            console.error('Failed to get selected keyframes');
            return;
        }
        
        // Sort keyframes by time
        const [startKeyframe, endKeyframe] = keyframe1.time < keyframe2.time ? 
            [keyframe1, keyframe2] : [keyframe2, keyframe1];
        
        // Create the tween
        import('../core/DataModel').then(({ TweenType }) => {
            const tweenType = type === 'motion' ? TweenType.MOTION : TweenType.SHAPE;
            
            // Create tween object
            const tweenId = `tween-${Date.now()}`;
            const tween = {
                id: tweenId,
                startKeyframeId: startKeyframe.id,
                endKeyframeId: endKeyframe.id,
                type: tweenType,
                properties: [] // Empty array for properties being tweened
            };
            
            // Update the start keyframe with the tween
            this.dataModel.updateKeyframe(layerId, startKeyframe.id, {
                ...startKeyframe,
                nextTween: tween
            });
        });
    }
    
    /**
     * Toggle playback state (play/pause)
     */
    private togglePlayback(): void {
        // This is a placeholder for playback functionality
        // In a real implementation, this would start/stop animation
        console.log('Toggle playback');
        this.eventEmitter.emit(Events.TOGGLE_PLAYBACK, {}, this);
    }
    
    /**
     * Step backward one frame
     */
    private stepBackward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.max(0, currentTime - frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
    
    /**
     * Step forward one frame
     */
    private stepForward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const duration = this.dataModel.getDuration();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.min(duration, currentTime + frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
      /**
     * Render the timeline control
     * @returns HTML string representation
     */
    public render(): string {
        return `
            <div class="${CssClasses.TIMELINE_CONTROL}" id="${this.id}">
                <div class="${CssClasses.TIMELINE_TOOLBAR}"></div>
                <div class="${CssClasses.TIMELINE_CONTENT}">
                    <div class="${CssClasses.TIMELINE_CONTENT_CONTAINER}">                        <div class="${CssClasses.TIMELINE_LAYERS_CONTAINER}">
                            <div class="${CssClasses.TIMELINE_LAYERS_HEADER}"></div>
                            <div class="${CssClasses.LAYER_LIST}"></div>
                            <div class="${CssClasses.TIMELINE_LAYERS_TOOLBAR}"></div>
                        </div>
                        <div class="${CssClasses.TIMELINE_KEYFRAMES_AREA}">
                            <div class="${CssClasses.TIMELINE_RULER}"></div>
                            <div class="${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}"></div>
                            <div class="${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}"></div>
                        </div>
                    </div>
                </div>
                <div class="${CssClasses.TIMELINE_OBJECT_TOOLBAR}"></div>
            </div>
        `;
    }
      /**
     * Update the timeline control
     * @param data - New data for the timeline
     */
    public update(data?: any): void {
        if (data) {
            this.dataModel.setState(data);
        }
        
        // Verify default layer to ensure we always have at least one layer
        this.verifyDefaultLayer();
    }
    
    /**
     * Destroy the timeline control and clean up resources
     */
    public destroy(): void {
        // Destroy all plugins
        this.pluginManager.destroyAll();
        
        // Remove event listeners
        this.eventEmitter.clear();
        
        // Emit destroyed event
        this.eventEmitter.emit(Events.TIMELINE_DESTROYED, {}, this);
    }
    
    /**
     * Create the DOM structure for the timeline control
     */    private createDomStructure(): void {
        // Check if element already exists
        if (!this.element) {
            // Render without initializing to avoid recursion
            const html = this.render();
            this.container.innerHTML = html;
            this.element = this.container.firstElementChild as HTMLElement;
        }
        
        // Get the DOM elements
        if (!this.element) {
            throw new Error('Failed to create timeline control element');
        }
        
        this.toolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_TOOLBAR}`);
        this.contentEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT}`);
        this.contentContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT_CONTAINER}`);        this.layersContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_CONTAINER}`);
        this.layersHeaderEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_HEADER}`);
        this.layersListEl = this.element.querySelector(`.${CssClasses.LAYER_LIST}`);
        this.layersToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_TOOLBAR}`);
        this.keyframesAreaEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_AREA}`);
        this.timeRulerEl = this.element.querySelector(`.${CssClasses.TIMELINE_RULER}`);
        this.keyframesContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}`);
        this.playbackToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}`);
        this.objectToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_OBJECT_TOOLBAR}`);
        
        // Initialize the layers header with column titles
        if (this.layersHeaderEl) {
            this.layersHeaderEl.innerHTML = `
                <div class="layers-header-title">Layers</div>
                <div class="layers-header-actions">
                    <span class="header-icon" title="Toggle visibility of all layers">👁️</span>
                    <span class="header-icon" title="Toggle lock of all layers">🔓</span>
                </div>
            `;
        }
          
        if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
            !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || !this.objectToolbarEl ||
            !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl || !this.playbackToolbarEl) {
            throw new Error('Failed to get all timeline control elements');
        }
    }    /**
     * Set up scroll synchronization between layers and keyframes
     */
    private setupScrollSynchronization(): void {
        if (!this.layersContainerEl || !this.layersListEl || !this.keyframesContainerEl || !this.timeRulerEl) {
            throw new Error('Cannot set up scroll synchronization - required elements not found');
        }
        
        console.log('Setting up scroll synchronization...');
        
        // Sync vertical scrolling with debouncing to prevent loops
        let isScrollingKeyframes = false;
        let isScrollingLayers = false;
        
        // Keyframes to Layers sync
        this.keyframesContainerEl.addEventListener('scroll', () => {
            if (!isScrollingLayers && this.layersListEl) {
                isScrollingKeyframes = true;
                this.layersListEl.scrollTop = this.keyframesContainerEl!.scrollTop;
                setTimeout(() => { isScrollingKeyframes = false; }, 10);
            }
        });
        
        // Layers to Keyframes sync
        this.layersListEl.addEventListener('scroll', () => {
            if (!isScrollingKeyframes && this.keyframesContainerEl) {
                isScrollingLayers = true;
                this.keyframesContainerEl.scrollTop = this.layersListEl!.scrollTop;
                setTimeout(() => { isScrollingLayers = false; }, 10);
            }
        });
        
        // Sync horizontal scrolling between ruler and keyframes
        this.keyframesContainerEl.addEventListener('scroll', () => {
            const rulerContent = this.timeRulerEl!.querySelector('.timeline-ruler-content');
            if (rulerContent) {
                (rulerContent as HTMLElement).style.transform = 
                    `translateX(-${this.keyframesContainerEl!.scrollLeft}px)`;
            } else {
                console.error('Ruler content element not found');
            }
            
            // Emit scroll event
            this.eventEmitter.emit(Events.SCROLL_HORIZONTAL, {
                position: this.keyframesContainerEl!.scrollLeft
            }, this);
        });
        
        console.log('Scroll synchronization set up successfully');
    }    /**
     * Handle resize event
     */
    private handleResize(): void {
        // Update the timeline display and verify alignment
        this.verifyAlignment();
        
        // Emit resize event
        this.eventEmitter.emit(Events.TIMELINE_RESIZED, {
            width: this.element?.clientWidth,
            height: this.element?.clientHeight
        }, this);
    }
    
    /**
     * Set up the toolbar components
     */
    private setupToolbar(): void {
        if (!this.toolbarEl) {
            throw new Error('Toolbar element not found');
        }
        
        console.log('Setting up toolbar components...');
        
        // Create scene selector
        this.sceneSelector = new SceneSelector({
            container: this.toolbarEl,
            dataModel: this.dataModel,
            eventEmitter: this.eventEmitter
        });
        
        this.sceneSelector.mount();
        this.sceneSelector.initialize();
        
        // Add keyframe button
        const addKeyframeBtn = document.createElement('button');
        addKeyframeBtn.className = CssClasses.ADD_KEYFRAME_BUTTON;
        addKeyframeBtn.textContent = 'Add Keyframe';
        addKeyframeBtn.title = 'Add a keyframe at the current time';
        addKeyframeBtn.addEventListener('click', this.handleAddKeyframeClick.bind(this));
        
        this.toolbarEl.appendChild(addKeyframeBtn);
        
        // Set up the layers container resize functionality
        this.setupLayersResize();
        
        // Set up keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    
    /**
     * Set up keyboard shortcuts for common timeline operations
     */
    private setupKeyboardShortcuts(): void {
        // Initialize the KeyboardHandler
        if (!this.keyboardHandler) {
            this.keyboardHandler = new KeyboardHandler({
                eventEmitter: this.eventEmitter,
                dataModel: this.dataModel,
                timelineElement: this.element as HTMLElement
            });
        }
    }
    
    /**
     * Handle adding a keyframe at the current playhead position
     */
    private handleAddKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.SOLID
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Handle adding a hollow keyframe at the current playhead position
     */
    private handleAddHollowKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a hollow keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.HOLLOW
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Create a tween between selected keyframes
     * @param type - Type of tween to create
     */
    private handleCreateTweenClick(type: 'motion' | 'shape'): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        
        if (selectedLayerIds.length !== 1) {
            console.warn('Please select exactly one layer for tween creation');
            return;
        }
        
        const layerId = selectedLayerIds[0];
        const selectedKeyframeIds = this.dataModel.getSelectedKeyframeIds(layerId);
        
        if (selectedKeyframeIds.length !== 2) {
            console.warn('Please select exactly two keyframes for tween creation');
            return;
        }
        
        // Get the keyframes and sort them by time
        const keyframe1 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[0]);
        const keyframe2 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[1]);
        
        if (!keyframe1 || !keyframe2) {
            console.error('Failed to get selected keyframes');
            return;
        }
        
        // Sort keyframes by time
        const [startKeyframe, endKeyframe] = keyframe1.time < keyframe2.time ? 
            [keyframe1, keyframe2] : [keyframe2, keyframe1];
        
        // Create the tween
        import('../core/DataModel').then(({ TweenType }) => {
            const tweenType = type === 'motion' ? TweenType.MOTION : TweenType.SHAPE;
            
            // Create tween object
            const tweenId = `tween-${Date.now()}`;
            const tween = {
                id: tweenId,
                startKeyframeId: startKeyframe.id,
                endKeyframeId: endKeyframe.id,
                type: tweenType,
                properties: [] // Empty array for properties being tweened
            };
            
            // Update the start keyframe with the tween
            this.dataModel.updateKeyframe(layerId, startKeyframe.id, {
                ...startKeyframe,
                nextTween: tween
            });
        });
    }
    
    /**
     * Toggle playback state (play/pause)
     */
    private togglePlayback(): void {
        // This is a placeholder for playback functionality
        // In a real implementation, this would start/stop animation
        console.log('Toggle playback');
        this.eventEmitter.emit(Events.TOGGLE_PLAYBACK, {}, this);
    }
    
    /**
     * Step backward one frame
     */
    private stepBackward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.max(0, currentTime - frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
    
    /**
     * Step forward one frame
     */
    private stepForward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const duration = this.dataModel.getDuration();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.min(duration, currentTime + frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
      /**
     * Render the timeline control
     * @returns HTML string representation
     */
    public render(): string {
        return `
            <div class="${CssClasses.TIMELINE_CONTROL}" id="${this.id}">
                <div class="${CssClasses.TIMELINE_TOOLBAR}"></div>
                <div class="${CssClasses.TIMELINE_CONTENT}">
                    <div class="${CssClasses.TIMELINE_CONTENT_CONTAINER}">                        <div class="${CssClasses.TIMELINE_LAYERS_CONTAINER}">
                            <div class="${CssClasses.TIMELINE_LAYERS_HEADER}"></div>
                            <div class="${CssClasses.LAYER_LIST}"></div>
                            <div class="${CssClasses.TIMELINE_LAYERS_TOOLBAR}"></div>
                        </div>
                        <div class="${CssClasses.TIMELINE_KEYFRAMES_AREA}">
                            <div class="${CssClasses.TIMELINE_RULER}"></div>
                            <div class="${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}"></div>
                            <div class="${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}"></div>
                        </div>
                    </div>
                </div>
                <div class="${CssClasses.TIMELINE_OBJECT_TOOLBAR}"></div>
            </div>
        `;
    }
      /**
     * Update the timeline control
     * @param data - New data for the timeline
     */
    public update(data?: any): void {
        if (data) {
            this.dataModel.setState(data);
        }
        
        // Verify default layer to ensure we always have at least one layer
        this.verifyDefaultLayer();
    }
    
    /**
     * Destroy the timeline control and clean up resources
     */
    public destroy(): void {
        // Destroy all plugins
        this.pluginManager.destroyAll();
        
        // Remove event listeners
        this.eventEmitter.clear();
        
        // Emit destroyed event
        this.eventEmitter.emit(Events.TIMELINE_DESTROYED, {}, this);
    }
    
    /**
     * Create the DOM structure for the timeline control
     */    private createDomStructure(): void {
        // Check if element already exists
        if (!this.element) {
            // Render without initializing to avoid recursion
            const html = this.render();
            this.container.innerHTML = html;
            this.element = this.container.firstElementChild as HTMLElement;
        }
        
        // Get the DOM elements
        if (!this.element) {
            throw new Error('Failed to create timeline control element');
        }
        
        this.toolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_TOOLBAR}`);
        this.contentEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT}`);
        this.contentContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_CONTENT_CONTAINER}`);        this.layersContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_CONTAINER}`);
        this.layersHeaderEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_HEADER}`);
        this.layersListEl = this.element.querySelector(`.${CssClasses.LAYER_LIST}`);
        this.layersToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_LAYERS_TOOLBAR}`);
        this.keyframesAreaEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_AREA}`);
        this.timeRulerEl = this.element.querySelector(`.${CssClasses.TIMELINE_RULER}`);
        this.keyframesContainerEl = this.element.querySelector(`.${CssClasses.TIMELINE_KEYFRAMES_CONTAINER}`);
        this.playbackToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_PLAYBACK_TOOLBAR}`);
        this.objectToolbarEl = this.element.querySelector(`.${CssClasses.TIMELINE_OBJECT_TOOLBAR}`);
        
        // Initialize the layers header with column titles
        if (this.layersHeaderEl) {
            this.layersHeaderEl.innerHTML = `
                <div class="layers-header-title">Layers</div>
                <div class="layers-header-actions">
                    <span class="header-icon" title="Toggle visibility of all layers">👁️</span>
                    <span class="header-icon" title="Toggle lock of all layers">🔓</span>
                </div>
            `;
        }
          
        if (!this.toolbarEl || !this.contentEl || !this.contentContainerEl || !this.layersContainerEl ||
            !this.keyframesAreaEl || !this.timeRulerEl || !this.keyframesContainerEl || !this.objectToolbarEl ||
            !this.layersHeaderEl || !this.layersListEl || !this.layersToolbarEl || !this.playbackToolbarEl) {
            throw new Error('Failed to get all timeline control elements');
        }
    }    /**
     * Set up scroll synchronization between layers and keyframes
     */
    private setupScrollSynchronization(): void {
        if (!this.layersContainerEl || !this.layersListEl || !this.keyframesContainerEl || !this.timeRulerEl) {
            throw new Error('Cannot set up scroll synchronization - required elements not found');
        }
        
        console.log('Setting up scroll synchronization...');
        
        // Sync vertical scrolling with debouncing to prevent loops
        let isScrollingKeyframes = false;
        let isScrollingLayers = false;
        
        // Keyframes to Layers sync
        this.keyframesContainerEl.addEventListener('scroll', () => {
            if (!isScrollingLayers && this.layersListEl) {
                isScrollingKeyframes = true;
                this.layersListEl.scrollTop = this.keyframesContainerEl!.scrollTop;
                setTimeout(() => { isScrollingKeyframes = false; }, 10);
            }
        });
        
        // Layers to Keyframes sync
        this.layersListEl.addEventListener('scroll', () => {
            if (!isScrollingKeyframes && this.keyframesContainerEl) {
                isScrollingLayers = true;
                this.keyframesContainerEl.scrollTop = this.layersListEl!.scrollTop;
                setTimeout(() => { isScrollingLayers = false; }, 10);
            }
        });
        
        // Sync horizontal scrolling between ruler and keyframes
        this.keyframesContainerEl.addEventListener('scroll', () => {
            const rulerContent = this.timeRulerEl!.querySelector('.timeline-ruler-content');
            if (rulerContent) {
                (rulerContent as HTMLElement).style.transform = 
                    `translateX(-${this.keyframesContainerEl!.scrollLeft}px)`;
            } else {
                console.error('Ruler content element not found');
            }
            
            // Emit scroll event
            this.eventEmitter.emit(Events.SCROLL_HORIZONTAL, {
                position: this.keyframesContainerEl!.scrollLeft
            }, this);
        });
        
        console.log('Scroll synchronization set up successfully');
    }    /**
     * Handle resize event
     */
    private handleResize(): void {
        // Update the timeline display and verify alignment
        this.verifyAlignment();
        
        // Emit resize event
        this.eventEmitter.emit(Events.TIMELINE_RESIZED, {
            width: this.element?.clientWidth,
            height: this.element?.clientHeight
        }, this);
    }
    
    /**
     * Set up the toolbar components
     */
    private setupToolbar(): void {
        if (!this.toolbarEl) {
            throw new Error('Toolbar element not found');
        }
        
        console.log('Setting up toolbar components...');
        
        // Create scene selector
        this.sceneSelector = new SceneSelector({
            container: this.toolbarEl,
            dataModel: this.dataModel,
            eventEmitter: this.eventEmitter
        });
        
        this.sceneSelector.mount();
        this.sceneSelector.initialize();
        
        // Add keyframe button
        const addKeyframeBtn = document.createElement('button');
        addKeyframeBtn.className = CssClasses.ADD_KEYFRAME_BUTTON;
        addKeyframeBtn.textContent = 'Add Keyframe';
        addKeyframeBtn.title = 'Add a keyframe at the current time';
        addKeyframeBtn.addEventListener('click', this.handleAddKeyframeClick.bind(this));
        
        this.toolbarEl.appendChild(addKeyframeBtn);
        
        // Set up the layers container resize functionality
        this.setupLayersResize();
        
        // Set up keyboard shortcuts
        this.setupKeyboardShortcuts();
    }
    
    /**
     * Set up keyboard shortcuts for common timeline operations
     */
    private setupKeyboardShortcuts(): void {
        // Initialize the KeyboardHandler
        if (!this.keyboardHandler) {
            this.keyboardHandler = new KeyboardHandler({
                eventEmitter: this.eventEmitter,
                dataModel: this.dataModel,
                timelineElement: this.element as HTMLElement
            });
        }
    }
    
    /**
     * Handle adding a keyframe at the current playhead position
     */
    private handleAddKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.SOLID
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Handle adding a hollow keyframe at the current playhead position
     */
    private handleAddHollowKeyframeClick(): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        const currentTime = this.dataModel.getCurrentTime();
        
        if (selectedLayerIds.length === 0) {
            console.warn('No layer selected for keyframe addition');
            return;
        }
        
        // Add a hollow keyframe to each selected layer
        selectedLayerIds.forEach(layerId => {
            const keyframeId = `keyframe-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            const keyframe = {
                id: keyframeId,
                time: currentTime,
                value: {}, // Default value
                type: KeyframeType.HOLLOW
            };
            
            this.dataModel.addKeyframe(layerId, keyframe);
        });
    }
    
    /**
     * Create a tween between selected keyframes
     * @param type - Type of tween to create
     */
    private handleCreateTweenClick(type: 'motion' | 'shape'): void {
        const selectedLayerIds = this.dataModel.getSelectedLayerIds();
        
        if (selectedLayerIds.length !== 1) {
            console.warn('Please select exactly one layer for tween creation');
            return;
        }
        
        const layerId = selectedLayerIds[0];
        const selectedKeyframeIds = this.dataModel.getSelectedKeyframeIds(layerId);
        
        if (selectedKeyframeIds.length !== 2) {
            console.warn('Please select exactly two keyframes for tween creation');
            return;
        }
        
        // Get the keyframes and sort them by time
        const keyframe1 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[0]);
        const keyframe2 = this.dataModel.getKeyframe(layerId, selectedKeyframeIds[1]);
        
        if (!keyframe1 || !keyframe2) {
            console.error('Failed to get selected keyframes');
            return;
        }
        
        // Sort keyframes by time
        const [startKeyframe, endKeyframe] = keyframe1.time < keyframe2.time ? 
            [keyframe1, keyframe2] : [keyframe2, keyframe1];
        
        // Create the tween
        import('../core/DataModel').then(({ TweenType }) => {
            const tweenType = type === 'motion' ? TweenType.MOTION : TweenType.SHAPE;
            
            // Create tween object
            const tweenId = `tween-${Date.now()}`;
            const tween = {
                id: tweenId,
                startKeyframeId: startKeyframe.id,
                endKeyframeId: endKeyframe.id,
                type: tweenType,
                properties: [] // Empty array for properties being tweened
            };
            
            // Update the start keyframe with the tween
            this.dataModel.updateKeyframe(layerId, startKeyframe.id, {
                ...startKeyframe,
                nextTween: tween
            });
        });
    }
    
    /**
     * Toggle playback state (play/pause)
     */
    private togglePlayback(): void {
        // This is a placeholder for playback functionality
        // In a real implementation, this would start/stop animation
        console.log('Toggle playback');
        this.eventEmitter.emit(Events.TOGGLE_PLAYBACK, {}, this);
    }
    
    /**
     * Step backward one frame
     */
    private stepBackward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.max(0, currentTime - frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
    
    /**
     * Step forward one frame
     */
    private stepForward(): void {
        const currentTime = this.dataModel.getCurrentTime();
        const duration = this.dataModel.getDuration();
        const fps = this.dataModel.getFps();
        const frameDuration = 1 / fps;
        
        const newTime = Math.min(duration, currentTime + frameDuration);
        this.dataModel.setCurrentTime(newTime);
        this.eventEmitter.emit(Events.SEEK, { time: newTime }, this);
    }
}